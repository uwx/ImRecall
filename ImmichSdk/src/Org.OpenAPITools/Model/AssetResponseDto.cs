// <auto-generated>
/*
 * Immich
 *
 * Immich API
 *
 * The version of the OpenAPI document: 2.1.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Org.OpenAPITools.Client;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// AssetResponseDto
    /// </summary>
    public partial class AssetResponseDto : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssetResponseDto" /> class.
        /// </summary>
        /// <param name="checksum">base64 encoded sha1 hash</param>
        /// <param name="createdAt">The UTC timestamp when the asset was originally uploaded to Immich.</param>
        /// <param name="deviceAssetId">deviceAssetId</param>
        /// <param name="deviceId">deviceId</param>
        /// <param name="duration">duration</param>
        /// <param name="fileCreatedAt">The actual UTC timestamp when the file was created/captured, preserving timezone information. This is the authoritative timestamp for chronological sorting within timeline groups. Combined with timezone data, this can be used to determine the exact moment the photo was taken.</param>
        /// <param name="fileModifiedAt">The UTC timestamp when the file was last modified on the filesystem. This reflects the last time the physical file was changed, which may be different from when the photo was originally taken.</param>
        /// <param name="hasMetadata">hasMetadata</param>
        /// <param name="id">id</param>
        /// <param name="isArchived">isArchived</param>
        /// <param name="isFavorite">isFavorite</param>
        /// <param name="isOffline">isOffline</param>
        /// <param name="isTrashed">isTrashed</param>
        /// <param name="localDateTime">The local date and time when the photo/video was taken, derived from EXIF metadata. This represents the photographer&#39;s local time regardless of timezone, stored as a timezone-agnostic timestamp. Used for timeline grouping by \&quot;local\&quot; days and months.</param>
        /// <param name="originalFileName">originalFileName</param>
        /// <param name="originalPath">originalPath</param>
        /// <param name="ownerId">ownerId</param>
        /// <param name="type">type</param>
        /// <param name="updatedAt">The UTC timestamp when the asset record was last updated in the database. This is automatically maintained by the database and reflects when any field in the asset was last modified.</param>
        /// <param name="visibility">visibility</param>
        /// <param name="duplicateId">duplicateId</param>
        /// <param name="exifInfo">exifInfo</param>
        /// <param name="libraryId">This property was deprecated in v1.106.0</param>
        /// <param name="livePhotoVideoId">livePhotoVideoId</param>
        /// <param name="originalMimeType">originalMimeType</param>
        /// <param name="owner">owner</param>
        /// <param name="people">people</param>
        /// <param name="resized">This property was deprecated in v1.113.0</param>
        /// <param name="stack">stack</param>
        /// <param name="tags">tags</param>
        /// <param name="thumbhash">thumbhash</param>
        /// <param name="unassignedFaces">unassignedFaces</param>
        [JsonConstructor]
        public AssetResponseDto(string checksum, DateTime createdAt, string deviceAssetId, string deviceId, string duration, DateTime fileCreatedAt, DateTime fileModifiedAt, bool hasMetadata, string id, bool isArchived, bool isFavorite, bool isOffline, bool isTrashed, DateTime localDateTime, string originalFileName, string originalPath, string ownerId, AssetTypeEnum type, DateTime updatedAt, AssetVisibility visibility, Option<string?> duplicateId = default, Option<ExifResponseDto?> exifInfo = default, Option<string?> libraryId = default, Option<string?> livePhotoVideoId = default, Option<string?> originalMimeType = default, Option<UserResponseDto?> owner = default, Option<List<PersonWithFacesResponseDto>?> people = default, Option<bool?> resized = default, Option<AssetStackResponseDto?> stack = default, Option<List<TagResponseDto>?> tags = default, string? thumbhash = default, Option<List<AssetFaceWithoutPersonResponseDto>?> unassignedFaces = default)
        {
            Checksum = checksum;
            CreatedAt = createdAt;
            DeviceAssetId = deviceAssetId;
            DeviceId = deviceId;
            Duration = duration;
            FileCreatedAt = fileCreatedAt;
            FileModifiedAt = fileModifiedAt;
            HasMetadata = hasMetadata;
            Id = id;
            IsArchived = isArchived;
            IsFavorite = isFavorite;
            IsOffline = isOffline;
            IsTrashed = isTrashed;
            LocalDateTime = localDateTime;
            OriginalFileName = originalFileName;
            OriginalPath = originalPath;
            OwnerId = ownerId;
            Type = type;
            UpdatedAt = updatedAt;
            Visibility = visibility;
            DuplicateIdOption = duplicateId;
            ExifInfoOption = exifInfo;
            LibraryIdOption = libraryId;
            LivePhotoVideoIdOption = livePhotoVideoId;
            OriginalMimeTypeOption = originalMimeType;
            OwnerOption = owner;
            PeopleOption = people;
            ResizedOption = resized;
            StackOption = stack;
            TagsOption = tags;
            Thumbhash = thumbhash;
            UnassignedFacesOption = unassignedFaces;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [JsonPropertyName("type")]
        public AssetTypeEnum Type { get; set; }

        /// <summary>
        /// Gets or Sets Visibility
        /// </summary>
        [JsonPropertyName("visibility")]
        public AssetVisibility Visibility { get; set; }

        /// <summary>
        /// base64 encoded sha1 hash
        /// </summary>
        /// <value>base64 encoded sha1 hash</value>
        [JsonPropertyName("checksum")]
        public string Checksum { get; set; }

        /// <summary>
        /// The UTC timestamp when the asset was originally uploaded to Immich.
        /// </summary>
        /// <value>The UTC timestamp when the asset was originally uploaded to Immich.</value>
        /* <example>2024-01-15T20:30Z</example> */
        [JsonPropertyName("createdAt")]
        public DateTime CreatedAt { get; set; }

        /// <summary>
        /// Gets or Sets DeviceAssetId
        /// </summary>
        [JsonPropertyName("deviceAssetId")]
        public string DeviceAssetId { get; set; }

        /// <summary>
        /// Gets or Sets DeviceId
        /// </summary>
        [JsonPropertyName("deviceId")]
        public string DeviceId { get; set; }

        /// <summary>
        /// Gets or Sets Duration
        /// </summary>
        [JsonPropertyName("duration")]
        public string Duration { get; set; }

        /// <summary>
        /// The actual UTC timestamp when the file was created/captured, preserving timezone information. This is the authoritative timestamp for chronological sorting within timeline groups. Combined with timezone data, this can be used to determine the exact moment the photo was taken.
        /// </summary>
        /// <value>The actual UTC timestamp when the file was created/captured, preserving timezone information. This is the authoritative timestamp for chronological sorting within timeline groups. Combined with timezone data, this can be used to determine the exact moment the photo was taken.</value>
        /* <example>2024-01-15T19:30Z</example> */
        [JsonPropertyName("fileCreatedAt")]
        public DateTime FileCreatedAt { get; set; }

        /// <summary>
        /// The UTC timestamp when the file was last modified on the filesystem. This reflects the last time the physical file was changed, which may be different from when the photo was originally taken.
        /// </summary>
        /// <value>The UTC timestamp when the file was last modified on the filesystem. This reflects the last time the physical file was changed, which may be different from when the photo was originally taken.</value>
        /* <example>2024-01-16T10:15Z</example> */
        [JsonPropertyName("fileModifiedAt")]
        public DateTime FileModifiedAt { get; set; }

        /// <summary>
        /// Gets or Sets HasMetadata
        /// </summary>
        [JsonPropertyName("hasMetadata")]
        public bool HasMetadata { get; set; }

        /// <summary>
        /// Gets or Sets Id
        /// </summary>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Gets or Sets IsArchived
        /// </summary>
        [JsonPropertyName("isArchived")]
        public bool IsArchived { get; set; }

        /// <summary>
        /// Gets or Sets IsFavorite
        /// </summary>
        [JsonPropertyName("isFavorite")]
        public bool IsFavorite { get; set; }

        /// <summary>
        /// Gets or Sets IsOffline
        /// </summary>
        [JsonPropertyName("isOffline")]
        public bool IsOffline { get; set; }

        /// <summary>
        /// Gets or Sets IsTrashed
        /// </summary>
        [JsonPropertyName("isTrashed")]
        public bool IsTrashed { get; set; }

        /// <summary>
        /// The local date and time when the photo/video was taken, derived from EXIF metadata. This represents the photographer&#39;s local time regardless of timezone, stored as a timezone-agnostic timestamp. Used for timeline grouping by \&quot;local\&quot; days and months.
        /// </summary>
        /// <value>The local date and time when the photo/video was taken, derived from EXIF metadata. This represents the photographer&#39;s local time regardless of timezone, stored as a timezone-agnostic timestamp. Used for timeline grouping by \&quot;local\&quot; days and months.</value>
        /* <example>2024-01-15T14:30Z</example> */
        [JsonPropertyName("localDateTime")]
        public DateTime LocalDateTime { get; set; }

        /// <summary>
        /// Gets or Sets OriginalFileName
        /// </summary>
        [JsonPropertyName("originalFileName")]
        public string OriginalFileName { get; set; }

        /// <summary>
        /// Gets or Sets OriginalPath
        /// </summary>
        [JsonPropertyName("originalPath")]
        public string OriginalPath { get; set; }

        /// <summary>
        /// Gets or Sets OwnerId
        /// </summary>
        [JsonPropertyName("ownerId")]
        public string OwnerId { get; set; }

        /// <summary>
        /// The UTC timestamp when the asset record was last updated in the database. This is automatically maintained by the database and reflects when any field in the asset was last modified.
        /// </summary>
        /// <value>The UTC timestamp when the asset record was last updated in the database. This is automatically maintained by the database and reflects when any field in the asset was last modified.</value>
        /* <example>2024-01-16T12:45:30Z</example> */
        [JsonPropertyName("updatedAt")]
        public DateTime UpdatedAt { get; set; }

        /// <summary>
        /// Used to track the state of DuplicateId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DuplicateIdOption { get; private set; }

        /// <summary>
        /// Gets or Sets DuplicateId
        /// </summary>
        [JsonPropertyName("duplicateId")]
        public string? DuplicateId { get { return this.DuplicateIdOption; } set { this.DuplicateIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of ExifInfo
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ExifResponseDto?> ExifInfoOption { get; private set; }

        /// <summary>
        /// Gets or Sets ExifInfo
        /// </summary>
        [JsonPropertyName("exifInfo")]
        public ExifResponseDto? ExifInfo { get { return this.ExifInfoOption; } set { this.ExifInfoOption = new(value); } }

        /// <summary>
        /// Used to track the state of LibraryId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> LibraryIdOption { get; private set; }

        /// <summary>
        /// This property was deprecated in v1.106.0
        /// </summary>
        /// <value>This property was deprecated in v1.106.0</value>
        [JsonPropertyName("libraryId")]
        [Obsolete]
        public string? LibraryId { get { return this.LibraryIdOption; } set { this.LibraryIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of LivePhotoVideoId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> LivePhotoVideoIdOption { get; private set; }

        /// <summary>
        /// Gets or Sets LivePhotoVideoId
        /// </summary>
        [JsonPropertyName("livePhotoVideoId")]
        public string? LivePhotoVideoId { get { return this.LivePhotoVideoIdOption; } set { this.LivePhotoVideoIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of OriginalMimeType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> OriginalMimeTypeOption { get; private set; }

        /// <summary>
        /// Gets or Sets OriginalMimeType
        /// </summary>
        [JsonPropertyName("originalMimeType")]
        public string? OriginalMimeType { get { return this.OriginalMimeTypeOption; } set { this.OriginalMimeTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of Owner
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<UserResponseDto?> OwnerOption { get; private set; }

        /// <summary>
        /// Gets or Sets Owner
        /// </summary>
        [JsonPropertyName("owner")]
        public UserResponseDto? Owner { get { return this.OwnerOption; } set { this.OwnerOption = new(value); } }

        /// <summary>
        /// Used to track the state of People
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<PersonWithFacesResponseDto>?> PeopleOption { get; private set; }

        /// <summary>
        /// Gets or Sets People
        /// </summary>
        [JsonPropertyName("people")]
        public List<PersonWithFacesResponseDto>? People { get { return this.PeopleOption; } set { this.PeopleOption = new(value); } }

        /// <summary>
        /// Used to track the state of Resized
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> ResizedOption { get; private set; }

        /// <summary>
        /// This property was deprecated in v1.113.0
        /// </summary>
        /// <value>This property was deprecated in v1.113.0</value>
        [JsonPropertyName("resized")]
        [Obsolete]
        public bool? Resized { get { return this.ResizedOption; } set { this.ResizedOption = new(value); } }

        /// <summary>
        /// Used to track the state of Stack
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AssetStackResponseDto?> StackOption { get; private set; }

        /// <summary>
        /// Gets or Sets Stack
        /// </summary>
        [JsonPropertyName("stack")]
        public AssetStackResponseDto? Stack { get { return this.StackOption; } set { this.StackOption = new(value); } }

        /// <summary>
        /// Used to track the state of Tags
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<TagResponseDto>?> TagsOption { get; private set; }

        /// <summary>
        /// Gets or Sets Tags
        /// </summary>
        [JsonPropertyName("tags")]
        public List<TagResponseDto>? Tags { get { return this.TagsOption; } set { this.TagsOption = new(value); } }

        /// <summary>
        /// Gets or Sets Thumbhash
        /// </summary>
        [JsonPropertyName("thumbhash")]
        public string? Thumbhash { get; set; }

        /// <summary>
        /// Used to track the state of UnassignedFaces
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<AssetFaceWithoutPersonResponseDto>?> UnassignedFacesOption { get; private set; }

        /// <summary>
        /// Gets or Sets UnassignedFaces
        /// </summary>
        [JsonPropertyName("unassignedFaces")]
        public List<AssetFaceWithoutPersonResponseDto>? UnassignedFaces { get { return this.UnassignedFacesOption; } set { this.UnassignedFacesOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class AssetResponseDto {\n");
            sb.Append("  Checksum: ").Append(Checksum).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  DeviceAssetId: ").Append(DeviceAssetId).Append("\n");
            sb.Append("  DeviceId: ").Append(DeviceId).Append("\n");
            sb.Append("  Duration: ").Append(Duration).Append("\n");
            sb.Append("  FileCreatedAt: ").Append(FileCreatedAt).Append("\n");
            sb.Append("  FileModifiedAt: ").Append(FileModifiedAt).Append("\n");
            sb.Append("  HasMetadata: ").Append(HasMetadata).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  IsArchived: ").Append(IsArchived).Append("\n");
            sb.Append("  IsFavorite: ").Append(IsFavorite).Append("\n");
            sb.Append("  IsOffline: ").Append(IsOffline).Append("\n");
            sb.Append("  IsTrashed: ").Append(IsTrashed).Append("\n");
            sb.Append("  LocalDateTime: ").Append(LocalDateTime).Append("\n");
            sb.Append("  OriginalFileName: ").Append(OriginalFileName).Append("\n");
            sb.Append("  OriginalPath: ").Append(OriginalPath).Append("\n");
            sb.Append("  OwnerId: ").Append(OwnerId).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
            sb.Append("  Visibility: ").Append(Visibility).Append("\n");
            sb.Append("  DuplicateId: ").Append(DuplicateId).Append("\n");
            sb.Append("  ExifInfo: ").Append(ExifInfo).Append("\n");
            sb.Append("  LibraryId: ").Append(LibraryId).Append("\n");
            sb.Append("  LivePhotoVideoId: ").Append(LivePhotoVideoId).Append("\n");
            sb.Append("  OriginalMimeType: ").Append(OriginalMimeType).Append("\n");
            sb.Append("  Owner: ").Append(Owner).Append("\n");
            sb.Append("  People: ").Append(People).Append("\n");
            sb.Append("  Resized: ").Append(Resized).Append("\n");
            sb.Append("  Stack: ").Append(Stack).Append("\n");
            sb.Append("  Tags: ").Append(Tags).Append("\n");
            sb.Append("  Thumbhash: ").Append(Thumbhash).Append("\n");
            sb.Append("  UnassignedFaces: ").Append(UnassignedFaces).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="AssetResponseDto" />
    /// </summary>
    public class AssetResponseDtoJsonConverter : JsonConverter<AssetResponseDto>
    {
        /// <summary>
        /// The format to use to serialize CreatedAt
        /// </summary>
        public static string CreatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize FileCreatedAt
        /// </summary>
        public static string FileCreatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize FileModifiedAt
        /// </summary>
        public static string FileModifiedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize LocalDateTime
        /// </summary>
        public static string LocalDateTimeFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize UpdatedAt
        /// </summary>
        public static string UpdatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="AssetResponseDto" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override AssetResponseDto Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> checksum = default;
            Option<DateTime?> createdAt = default;
            Option<string?> deviceAssetId = default;
            Option<string?> deviceId = default;
            Option<string?> duration = default;
            Option<DateTime?> fileCreatedAt = default;
            Option<DateTime?> fileModifiedAt = default;
            Option<bool?> hasMetadata = default;
            Option<string?> id = default;
            Option<bool?> isArchived = default;
            Option<bool?> isFavorite = default;
            Option<bool?> isOffline = default;
            Option<bool?> isTrashed = default;
            Option<DateTime?> localDateTime = default;
            Option<string?> originalFileName = default;
            Option<string?> originalPath = default;
            Option<string?> ownerId = default;
            Option<AssetTypeEnum?> type = default;
            Option<DateTime?> updatedAt = default;
            Option<AssetVisibility?> visibility = default;
            Option<string?> duplicateId = default;
            Option<ExifResponseDto?> exifInfo = default;
            Option<string?> libraryId = default;
            Option<string?> livePhotoVideoId = default;
            Option<string?> originalMimeType = default;
            Option<UserResponseDto?> owner = default;
            Option<List<PersonWithFacesResponseDto>?> people = default;
            Option<bool?> resized = default;
            Option<AssetStackResponseDto?> stack = default;
            Option<List<TagResponseDto>?> tags = default;
            Option<string?> thumbhash = default;
            Option<List<AssetFaceWithoutPersonResponseDto>?> unassignedFaces = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "checksum":
                            checksum = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "createdAt":
                            createdAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "deviceAssetId":
                            deviceAssetId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "deviceId":
                            deviceId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "duration":
                            duration = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "fileCreatedAt":
                            fileCreatedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "fileModifiedAt":
                            fileModifiedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "hasMetadata":
                            hasMetadata = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "id":
                            id = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "isArchived":
                            isArchived = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "isFavorite":
                            isFavorite = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "isOffline":
                            isOffline = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "isTrashed":
                            isTrashed = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "localDateTime":
                            localDateTime = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "originalFileName":
                            originalFileName = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "originalPath":
                            originalPath = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "ownerId":
                            ownerId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "type":
                            string? typeRawValue = utf8JsonReader.GetString();
                            if (typeRawValue != null)
                                type = new Option<AssetTypeEnum?>(AssetTypeEnumValueConverter.FromStringOrDefault(typeRawValue));
                            break;
                        case "updatedAt":
                            updatedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "visibility":
                            string? visibilityRawValue = utf8JsonReader.GetString();
                            if (visibilityRawValue != null)
                                visibility = new Option<AssetVisibility?>(AssetVisibilityValueConverter.FromStringOrDefault(visibilityRawValue));
                            break;
                        case "duplicateId":
                            duplicateId = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "exifInfo":
                            exifInfo = new Option<ExifResponseDto?>(JsonSerializer.Deserialize<ExifResponseDto>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "libraryId":
                            libraryId = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "livePhotoVideoId":
                            livePhotoVideoId = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "originalMimeType":
                            originalMimeType = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "owner":
                            owner = new Option<UserResponseDto?>(JsonSerializer.Deserialize<UserResponseDto>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "people":
                            people = new Option<List<PersonWithFacesResponseDto>?>(JsonSerializer.Deserialize<List<PersonWithFacesResponseDto>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "resized":
                            resized = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "stack":
                            stack = new Option<AssetStackResponseDto?>(JsonSerializer.Deserialize<AssetStackResponseDto>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "tags":
                            tags = new Option<List<TagResponseDto>?>(JsonSerializer.Deserialize<List<TagResponseDto>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "thumbhash":
                            thumbhash = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "unassignedFaces":
                            unassignedFaces = new Option<List<AssetFaceWithoutPersonResponseDto>?>(JsonSerializer.Deserialize<List<AssetFaceWithoutPersonResponseDto>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!checksum.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(checksum));

            if (!createdAt.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(createdAt));

            if (!deviceAssetId.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(deviceAssetId));

            if (!deviceId.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(deviceId));

            if (!duration.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(duration));

            if (!fileCreatedAt.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(fileCreatedAt));

            if (!fileModifiedAt.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(fileModifiedAt));

            if (!hasMetadata.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(hasMetadata));

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(id));

            if (!isArchived.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(isArchived));

            if (!isFavorite.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(isFavorite));

            if (!isOffline.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(isOffline));

            if (!isTrashed.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(isTrashed));

            if (!localDateTime.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(localDateTime));

            if (!originalFileName.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(originalFileName));

            if (!originalPath.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(originalPath));

            if (!ownerId.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(ownerId));

            if (!type.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(type));

            if (!updatedAt.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(updatedAt));

            if (!visibility.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(visibility));

            if (!thumbhash.IsSet)
                throw new ArgumentException("Property is required for class AssetResponseDto.", nameof(thumbhash));

            if (checksum.IsSet && checksum.Value == null)
                throw new ArgumentNullException(nameof(checksum), "Property is not nullable for class AssetResponseDto.");

            if (createdAt.IsSet && createdAt.Value == null)
                throw new ArgumentNullException(nameof(createdAt), "Property is not nullable for class AssetResponseDto.");

            if (deviceAssetId.IsSet && deviceAssetId.Value == null)
                throw new ArgumentNullException(nameof(deviceAssetId), "Property is not nullable for class AssetResponseDto.");

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId), "Property is not nullable for class AssetResponseDto.");

            if (duration.IsSet && duration.Value == null)
                throw new ArgumentNullException(nameof(duration), "Property is not nullable for class AssetResponseDto.");

            if (fileCreatedAt.IsSet && fileCreatedAt.Value == null)
                throw new ArgumentNullException(nameof(fileCreatedAt), "Property is not nullable for class AssetResponseDto.");

            if (fileModifiedAt.IsSet && fileModifiedAt.Value == null)
                throw new ArgumentNullException(nameof(fileModifiedAt), "Property is not nullable for class AssetResponseDto.");

            if (hasMetadata.IsSet && hasMetadata.Value == null)
                throw new ArgumentNullException(nameof(hasMetadata), "Property is not nullable for class AssetResponseDto.");

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class AssetResponseDto.");

            if (isArchived.IsSet && isArchived.Value == null)
                throw new ArgumentNullException(nameof(isArchived), "Property is not nullable for class AssetResponseDto.");

            if (isFavorite.IsSet && isFavorite.Value == null)
                throw new ArgumentNullException(nameof(isFavorite), "Property is not nullable for class AssetResponseDto.");

            if (isOffline.IsSet && isOffline.Value == null)
                throw new ArgumentNullException(nameof(isOffline), "Property is not nullable for class AssetResponseDto.");

            if (isTrashed.IsSet && isTrashed.Value == null)
                throw new ArgumentNullException(nameof(isTrashed), "Property is not nullable for class AssetResponseDto.");

            if (localDateTime.IsSet && localDateTime.Value == null)
                throw new ArgumentNullException(nameof(localDateTime), "Property is not nullable for class AssetResponseDto.");

            if (originalFileName.IsSet && originalFileName.Value == null)
                throw new ArgumentNullException(nameof(originalFileName), "Property is not nullable for class AssetResponseDto.");

            if (originalPath.IsSet && originalPath.Value == null)
                throw new ArgumentNullException(nameof(originalPath), "Property is not nullable for class AssetResponseDto.");

            if (ownerId.IsSet && ownerId.Value == null)
                throw new ArgumentNullException(nameof(ownerId), "Property is not nullable for class AssetResponseDto.");

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type), "Property is not nullable for class AssetResponseDto.");

            if (updatedAt.IsSet && updatedAt.Value == null)
                throw new ArgumentNullException(nameof(updatedAt), "Property is not nullable for class AssetResponseDto.");

            if (visibility.IsSet && visibility.Value == null)
                throw new ArgumentNullException(nameof(visibility), "Property is not nullable for class AssetResponseDto.");

            if (exifInfo.IsSet && exifInfo.Value == null)
                throw new ArgumentNullException(nameof(exifInfo), "Property is not nullable for class AssetResponseDto.");

            if (originalMimeType.IsSet && originalMimeType.Value == null)
                throw new ArgumentNullException(nameof(originalMimeType), "Property is not nullable for class AssetResponseDto.");

            if (owner.IsSet && owner.Value == null)
                throw new ArgumentNullException(nameof(owner), "Property is not nullable for class AssetResponseDto.");

            if (people.IsSet && people.Value == null)
                throw new ArgumentNullException(nameof(people), "Property is not nullable for class AssetResponseDto.");

            if (resized.IsSet && resized.Value == null)
                throw new ArgumentNullException(nameof(resized), "Property is not nullable for class AssetResponseDto.");

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags), "Property is not nullable for class AssetResponseDto.");

            if (unassignedFaces.IsSet && unassignedFaces.Value == null)
                throw new ArgumentNullException(nameof(unassignedFaces), "Property is not nullable for class AssetResponseDto.");

            return new AssetResponseDto(checksum.Value!, createdAt.Value!.Value!, deviceAssetId.Value!, deviceId.Value!, duration.Value!, fileCreatedAt.Value!.Value!, fileModifiedAt.Value!.Value!, hasMetadata.Value!.Value!, id.Value!, isArchived.Value!.Value!, isFavorite.Value!.Value!, isOffline.Value!.Value!, isTrashed.Value!.Value!, localDateTime.Value!.Value!, originalFileName.Value!, originalPath.Value!, ownerId.Value!, type.Value!.Value!, updatedAt.Value!.Value!, visibility.Value!.Value!, duplicateId, exifInfo, libraryId, livePhotoVideoId, originalMimeType, owner, people, resized, stack, tags, thumbhash.Value!, unassignedFaces);
        }

        /// <summary>
        /// Serializes a <see cref="AssetResponseDto" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="assetResponseDto"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, AssetResponseDto assetResponseDto, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, assetResponseDto, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="AssetResponseDto" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="assetResponseDto"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, AssetResponseDto assetResponseDto, JsonSerializerOptions jsonSerializerOptions)
        {
            if (assetResponseDto.Checksum == null)
                throw new ArgumentNullException(nameof(assetResponseDto.Checksum), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.DeviceAssetId == null)
                throw new ArgumentNullException(nameof(assetResponseDto.DeviceAssetId), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.DeviceId == null)
                throw new ArgumentNullException(nameof(assetResponseDto.DeviceId), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.Duration == null)
                throw new ArgumentNullException(nameof(assetResponseDto.Duration), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.Id == null)
                throw new ArgumentNullException(nameof(assetResponseDto.Id), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.OriginalFileName == null)
                throw new ArgumentNullException(nameof(assetResponseDto.OriginalFileName), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.OriginalPath == null)
                throw new ArgumentNullException(nameof(assetResponseDto.OriginalPath), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.OwnerId == null)
                throw new ArgumentNullException(nameof(assetResponseDto.OwnerId), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.ExifInfoOption.IsSet && assetResponseDto.ExifInfo == null)
                throw new ArgumentNullException(nameof(assetResponseDto.ExifInfo), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.OriginalMimeTypeOption.IsSet && assetResponseDto.OriginalMimeType == null)
                throw new ArgumentNullException(nameof(assetResponseDto.OriginalMimeType), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.OwnerOption.IsSet && assetResponseDto.Owner == null)
                throw new ArgumentNullException(nameof(assetResponseDto.Owner), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.PeopleOption.IsSet && assetResponseDto.People == null)
                throw new ArgumentNullException(nameof(assetResponseDto.People), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.TagsOption.IsSet && assetResponseDto.Tags == null)
                throw new ArgumentNullException(nameof(assetResponseDto.Tags), "Property is required for class AssetResponseDto.");

            if (assetResponseDto.UnassignedFacesOption.IsSet && assetResponseDto.UnassignedFaces == null)
                throw new ArgumentNullException(nameof(assetResponseDto.UnassignedFaces), "Property is required for class AssetResponseDto.");

            writer.WriteString("checksum", assetResponseDto.Checksum);

            writer.WriteString("createdAt", assetResponseDto.CreatedAt.ToString(CreatedAtFormat));

            writer.WriteString("deviceAssetId", assetResponseDto.DeviceAssetId);

            writer.WriteString("deviceId", assetResponseDto.DeviceId);

            writer.WriteString("duration", assetResponseDto.Duration);

            writer.WriteString("fileCreatedAt", assetResponseDto.FileCreatedAt.ToString(FileCreatedAtFormat));

            writer.WriteString("fileModifiedAt", assetResponseDto.FileModifiedAt.ToString(FileModifiedAtFormat));

            writer.WriteBoolean("hasMetadata", assetResponseDto.HasMetadata);

            writer.WriteString("id", assetResponseDto.Id);

            writer.WriteBoolean("isArchived", assetResponseDto.IsArchived);

            writer.WriteBoolean("isFavorite", assetResponseDto.IsFavorite);

            writer.WriteBoolean("isOffline", assetResponseDto.IsOffline);

            writer.WriteBoolean("isTrashed", assetResponseDto.IsTrashed);

            writer.WriteString("localDateTime", assetResponseDto.LocalDateTime.ToString(LocalDateTimeFormat));

            writer.WriteString("originalFileName", assetResponseDto.OriginalFileName);

            writer.WriteString("originalPath", assetResponseDto.OriginalPath);

            writer.WriteString("ownerId", assetResponseDto.OwnerId);

            var typeRawValue = AssetTypeEnumValueConverter.ToJsonValue(assetResponseDto.Type);
            writer.WriteString("type", typeRawValue);

            writer.WriteString("updatedAt", assetResponseDto.UpdatedAt.ToString(UpdatedAtFormat));

            var visibilityRawValue = AssetVisibilityValueConverter.ToJsonValue(assetResponseDto.Visibility);
            writer.WriteString("visibility", visibilityRawValue);

            if (assetResponseDto.DuplicateIdOption.IsSet)
                if (assetResponseDto.DuplicateIdOption.Value != null)
                    writer.WriteString("duplicateId", assetResponseDto.DuplicateId);
                else
                    writer.WriteNull("duplicateId");

            if (assetResponseDto.ExifInfoOption.IsSet)
            {
                writer.WritePropertyName("exifInfo");
                JsonSerializer.Serialize(writer, assetResponseDto.ExifInfo, jsonSerializerOptions);
            }
            if (assetResponseDto.LibraryIdOption.IsSet)
                if (assetResponseDto.LibraryIdOption.Value != null)
                    writer.WriteString("libraryId", assetResponseDto.LibraryId);
                else
                    writer.WriteNull("libraryId");

            if (assetResponseDto.LivePhotoVideoIdOption.IsSet)
                if (assetResponseDto.LivePhotoVideoIdOption.Value != null)
                    writer.WriteString("livePhotoVideoId", assetResponseDto.LivePhotoVideoId);
                else
                    writer.WriteNull("livePhotoVideoId");

            if (assetResponseDto.OriginalMimeTypeOption.IsSet)
                writer.WriteString("originalMimeType", assetResponseDto.OriginalMimeType);

            if (assetResponseDto.OwnerOption.IsSet)
            {
                writer.WritePropertyName("owner");
                JsonSerializer.Serialize(writer, assetResponseDto.Owner, jsonSerializerOptions);
            }
            if (assetResponseDto.PeopleOption.IsSet)
            {
                writer.WritePropertyName("people");
                JsonSerializer.Serialize(writer, assetResponseDto.People, jsonSerializerOptions);
            }
            if (assetResponseDto.ResizedOption.IsSet)
                writer.WriteBoolean("resized", assetResponseDto.ResizedOption.Value!.Value);

            if (assetResponseDto.StackOption.IsSet)
                if (assetResponseDto.StackOption.Value != null)
                {
                    writer.WritePropertyName("stack");
                    JsonSerializer.Serialize(writer, assetResponseDto.Stack, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("stack");
            if (assetResponseDto.TagsOption.IsSet)
            {
                writer.WritePropertyName("tags");
                JsonSerializer.Serialize(writer, assetResponseDto.Tags, jsonSerializerOptions);
            }
            if (assetResponseDto.Thumbhash != null)
                writer.WriteString("thumbhash", assetResponseDto.Thumbhash);
            else
                writer.WriteNull("thumbhash");

            if (assetResponseDto.UnassignedFacesOption.IsSet)
            {
                writer.WritePropertyName("unassignedFaces");
                JsonSerializer.Serialize(writer, assetResponseDto.UnassignedFaces, jsonSerializerOptions);
            }
        }
    }
}
