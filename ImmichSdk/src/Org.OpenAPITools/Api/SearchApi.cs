// <auto-generated>
/*
 * Immich
 *
 * Immich API
 *
 * The version of the OpenAPI document: 2.1.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ISearchApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        SearchApiEvents Events { get; }

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAssetsByCityApiResponse"/>&gt;</returns>
        Task<IGetAssetsByCityApiResponse> GetAssetsByCityAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAssetsByCityApiResponse"/>?&gt;</returns>
        Task<IGetAssetsByCityApiResponse?> GetAssetsByCityOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExploreDataApiResponse"/>&gt;</returns>
        Task<IGetExploreDataApiResponse> GetExploreDataAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExploreDataApiResponse"/>?&gt;</returns>
        Task<IGetExploreDataApiResponse?> GetExploreDataOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="type"></param>
        /// <param name="country"> (optional)</param>
        /// <param name="includeNull">This property was added in v111.0.0 (optional)</param>
        /// <param name="lensModel"> (optional)</param>
        /// <param name="make"> (optional)</param>
        /// <param name="model"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSearchSuggestionsApiResponse"/>&gt;</returns>
        Task<IGetSearchSuggestionsApiResponse> GetSearchSuggestionsAsync(SearchSuggestionType type, Option<string> country = default, Option<bool> includeNull = default, Option<string> lensModel = default, Option<string> make = default, Option<string> model = default, Option<string> state = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <param name="type"></param>
        /// <param name="country"> (optional)</param>
        /// <param name="includeNull">This property was added in v111.0.0 (optional)</param>
        /// <param name="lensModel"> (optional)</param>
        /// <param name="make"> (optional)</param>
        /// <param name="model"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSearchSuggestionsApiResponse"/>?&gt;</returns>
        Task<IGetSearchSuggestionsApiResponse?> GetSearchSuggestionsOrDefaultAsync(SearchSuggestionType type, Option<string> country = default, Option<bool> includeNull = default, Option<string> lensModel = default, Option<string> make = default, Option<string> model = default, Option<string> state = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.statistics&#x60; permission.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="statisticsSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchAssetStatisticsApiResponse"/>&gt;</returns>
        Task<ISearchAssetStatisticsApiResponse> SearchAssetStatisticsAsync(StatisticsSearchDto statisticsSearchDto, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.statistics&#x60; permission.
        /// </remarks>
        /// <param name="statisticsSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchAssetStatisticsApiResponse"/>?&gt;</returns>
        Task<ISearchAssetStatisticsApiResponse?> SearchAssetStatisticsOrDefaultAsync(StatisticsSearchDto statisticsSearchDto, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchAssetsApiResponse"/>&gt;</returns>
        Task<ISearchAssetsApiResponse> SearchAssetsAsync(MetadataSearchDto metadataSearchDto, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <param name="metadataSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchAssetsApiResponse"/>?&gt;</returns>
        Task<ISearchAssetsApiResponse?> SearchAssetsOrDefaultAsync(MetadataSearchDto metadataSearchDto, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="albumIds"> (optional)</param>
        /// <param name="city"> (optional)</param>
        /// <param name="country"> (optional)</param>
        /// <param name="createdAfter"> (optional)</param>
        /// <param name="createdBefore"> (optional)</param>
        /// <param name="deviceId"> (optional)</param>
        /// <param name="isEncoded"> (optional)</param>
        /// <param name="isFavorite"> (optional)</param>
        /// <param name="isMotion"> (optional)</param>
        /// <param name="isNotInAlbum"> (optional)</param>
        /// <param name="isOffline"> (optional)</param>
        /// <param name="lensModel"> (optional)</param>
        /// <param name="libraryId"> (optional)</param>
        /// <param name="make"> (optional)</param>
        /// <param name="minFileSize"> (optional)</param>
        /// <param name="model"> (optional)</param>
        /// <param name="personIds"> (optional)</param>
        /// <param name="rating"> (optional)</param>
        /// <param name="size"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="tagIds"> (optional)</param>
        /// <param name="takenAfter"> (optional)</param>
        /// <param name="takenBefore"> (optional)</param>
        /// <param name="trashedAfter"> (optional)</param>
        /// <param name="trashedBefore"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="updatedAfter"> (optional)</param>
        /// <param name="updatedBefore"> (optional)</param>
        /// <param name="visibility"> (optional)</param>
        /// <param name="withDeleted"> (optional)</param>
        /// <param name="withExif"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchLargeAssetsApiResponse"/>&gt;</returns>
        Task<ISearchLargeAssetsApiResponse> SearchLargeAssetsAsync(Option<List<Guid>> albumIds = default, Option<string?> city = default, Option<string?> country = default, Option<DateTime> createdAfter = default, Option<DateTime> createdBefore = default, Option<string> deviceId = default, Option<bool> isEncoded = default, Option<bool> isFavorite = default, Option<bool> isMotion = default, Option<bool> isNotInAlbum = default, Option<bool> isOffline = default, Option<string?> lensModel = default, Option<Guid?> libraryId = default, Option<string> make = default, Option<int> minFileSize = default, Option<string?> model = default, Option<List<Guid>> personIds = default, Option<decimal> rating = default, Option<decimal> size = default, Option<string?> state = default, Option<List<Guid>?> tagIds = default, Option<DateTime> takenAfter = default, Option<DateTime> takenBefore = default, Option<DateTime> trashedAfter = default, Option<DateTime> trashedBefore = default, Option<AssetTypeEnum> type = default, Option<DateTime> updatedAfter = default, Option<DateTime> updatedBefore = default, Option<AssetVisibility> visibility = default, Option<bool> withDeleted = default, Option<bool> withExif = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <param name="albumIds"> (optional)</param>
        /// <param name="city"> (optional)</param>
        /// <param name="country"> (optional)</param>
        /// <param name="createdAfter"> (optional)</param>
        /// <param name="createdBefore"> (optional)</param>
        /// <param name="deviceId"> (optional)</param>
        /// <param name="isEncoded"> (optional)</param>
        /// <param name="isFavorite"> (optional)</param>
        /// <param name="isMotion"> (optional)</param>
        /// <param name="isNotInAlbum"> (optional)</param>
        /// <param name="isOffline"> (optional)</param>
        /// <param name="lensModel"> (optional)</param>
        /// <param name="libraryId"> (optional)</param>
        /// <param name="make"> (optional)</param>
        /// <param name="minFileSize"> (optional)</param>
        /// <param name="model"> (optional)</param>
        /// <param name="personIds"> (optional)</param>
        /// <param name="rating"> (optional)</param>
        /// <param name="size"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="tagIds"> (optional)</param>
        /// <param name="takenAfter"> (optional)</param>
        /// <param name="takenBefore"> (optional)</param>
        /// <param name="trashedAfter"> (optional)</param>
        /// <param name="trashedBefore"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="updatedAfter"> (optional)</param>
        /// <param name="updatedBefore"> (optional)</param>
        /// <param name="visibility"> (optional)</param>
        /// <param name="withDeleted"> (optional)</param>
        /// <param name="withExif"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchLargeAssetsApiResponse"/>?&gt;</returns>
        Task<ISearchLargeAssetsApiResponse?> SearchLargeAssetsOrDefaultAsync(Option<List<Guid>> albumIds = default, Option<string?> city = default, Option<string?> country = default, Option<DateTime> createdAfter = default, Option<DateTime> createdBefore = default, Option<string> deviceId = default, Option<bool> isEncoded = default, Option<bool> isFavorite = default, Option<bool> isMotion = default, Option<bool> isNotInAlbum = default, Option<bool> isOffline = default, Option<string?> lensModel = default, Option<Guid?> libraryId = default, Option<string> make = default, Option<int> minFileSize = default, Option<string?> model = default, Option<List<Guid>> personIds = default, Option<decimal> rating = default, Option<decimal> size = default, Option<string?> state = default, Option<List<Guid>?> tagIds = default, Option<DateTime> takenAfter = default, Option<DateTime> takenBefore = default, Option<DateTime> trashedAfter = default, Option<DateTime> trashedBefore = default, Option<AssetTypeEnum> type = default, Option<DateTime> updatedAfter = default, Option<DateTime> updatedBefore = default, Option<AssetVisibility> visibility = default, Option<bool> withDeleted = default, Option<bool> withExif = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;person.read&#x60; permission.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="withHidden"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPersonApiResponse"/>&gt;</returns>
        Task<ISearchPersonApiResponse> SearchPersonAsync(string name, Option<bool> withHidden = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;person.read&#x60; permission.
        /// </remarks>
        /// <param name="name"></param>
        /// <param name="withHidden"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPersonApiResponse"/>?&gt;</returns>
        Task<ISearchPersonApiResponse?> SearchPersonOrDefaultAsync(string name, Option<bool> withHidden = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPlacesApiResponse"/>&gt;</returns>
        Task<ISearchPlacesApiResponse> SearchPlacesAsync(string name, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPlacesApiResponse"/>?&gt;</returns>
        Task<ISearchPlacesApiResponse?> SearchPlacesOrDefaultAsync(string name, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="randomSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRandomApiResponse"/>&gt;</returns>
        Task<ISearchRandomApiResponse> SearchRandomAsync(RandomSearchDto randomSearchDto, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <param name="randomSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRandomApiResponse"/>?&gt;</returns>
        Task<ISearchRandomApiResponse?> SearchRandomOrDefaultAsync(RandomSearchDto randomSearchDto, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="smartSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchSmartApiResponse"/>&gt;</returns>
        Task<ISearchSmartApiResponse> SearchSmartAsync(SmartSearchDto smartSearchDto, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </remarks>
        /// <param name="smartSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchSmartApiResponse"/>?&gt;</returns>
        Task<ISearchSmartApiResponse?> SearchSmartOrDefaultAsync(SmartSearchDto smartSearchDto, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetAssetsByCityApiResponse"/>
    /// </summary>
    public interface IGetAssetsByCityApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<AssetResponseDto>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetExploreDataApiResponse"/>
    /// </summary>
    public interface IGetExploreDataApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<SearchExploreResponseDto>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetSearchSuggestionsApiResponse"/>
    /// </summary>
    public interface IGetSearchSuggestionsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<string>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchAssetStatisticsApiResponse"/>
    /// </summary>
    public interface ISearchAssetStatisticsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SearchStatisticsResponseDto?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchAssetsApiResponse"/>
    /// </summary>
    public interface ISearchAssetsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SearchResponseDto?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchLargeAssetsApiResponse"/>
    /// </summary>
    public interface ISearchLargeAssetsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<AssetResponseDto>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchPersonApiResponse"/>
    /// </summary>
    public interface ISearchPersonApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<PersonResponseDto>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchPlacesApiResponse"/>
    /// </summary>
    public interface ISearchPlacesApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<PlacesResponseDto>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchRandomApiResponse"/>
    /// </summary>
    public interface ISearchRandomApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<AssetResponseDto>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchSmartApiResponse"/>
    /// </summary>
    public interface ISearchSmartApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SearchResponseDto?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class SearchApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetAssetsByCity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetAssetsByCity;

        internal void ExecuteOnGetAssetsByCity(SearchApi.GetAssetsByCityApiResponse apiResponse)
        {
            OnGetAssetsByCity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAssetsByCity(Exception exception)
        {
            OnErrorGetAssetsByCity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetExploreData;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetExploreData;

        internal void ExecuteOnGetExploreData(SearchApi.GetExploreDataApiResponse apiResponse)
        {
            OnGetExploreData?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetExploreData(Exception exception)
        {
            OnErrorGetExploreData?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSearchSuggestions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSearchSuggestions;

        internal void ExecuteOnGetSearchSuggestions(SearchApi.GetSearchSuggestionsApiResponse apiResponse)
        {
            OnGetSearchSuggestions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSearchSuggestions(Exception exception)
        {
            OnErrorGetSearchSuggestions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchAssetStatistics;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchAssetStatistics;

        internal void ExecuteOnSearchAssetStatistics(SearchApi.SearchAssetStatisticsApiResponse apiResponse)
        {
            OnSearchAssetStatistics?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchAssetStatistics(Exception exception)
        {
            OnErrorSearchAssetStatistics?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchAssets;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchAssets;

        internal void ExecuteOnSearchAssets(SearchApi.SearchAssetsApiResponse apiResponse)
        {
            OnSearchAssets?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchAssets(Exception exception)
        {
            OnErrorSearchAssets?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchLargeAssets;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchLargeAssets;

        internal void ExecuteOnSearchLargeAssets(SearchApi.SearchLargeAssetsApiResponse apiResponse)
        {
            OnSearchLargeAssets?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchLargeAssets(Exception exception)
        {
            OnErrorSearchLargeAssets?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchPerson;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchPerson;

        internal void ExecuteOnSearchPerson(SearchApi.SearchPersonApiResponse apiResponse)
        {
            OnSearchPerson?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchPerson(Exception exception)
        {
            OnErrorSearchPerson?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchPlaces;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchPlaces;

        internal void ExecuteOnSearchPlaces(SearchApi.SearchPlacesApiResponse apiResponse)
        {
            OnSearchPlaces?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchPlaces(Exception exception)
        {
            OnErrorSearchPlaces?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchRandom;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchRandom;

        internal void ExecuteOnSearchRandom(SearchApi.SearchRandomApiResponse apiResponse)
        {
            OnSearchRandom?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchRandom(Exception exception)
        {
            OnErrorSearchRandom?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchSmart;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchSmart;

        internal void ExecuteOnSearchSmart(SearchApi.SearchSmartApiResponse apiResponse)
        {
            OnSearchSmart?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchSmart(Exception exception)
        {
            OnErrorSearchSmart?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class SearchApi : ISearchApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<SearchApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public SearchApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SearchApi(ILogger<SearchApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, SearchApiEvents searchApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<SearchApi>();
            HttpClient = httpClient;
            Events = searchApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetAssetsByCityDefaultImplementation(IGetAssetsByCityApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetAssetsByCity(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetAssetsByCity(ref bool suppressDefaultLog, IGetAssetsByCityApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetAssetsByCityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAssetsByCity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetAssetsByCity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAssetsByCityApiResponse"/>&gt;</returns>
        public async Task<IGetAssetsByCityApiResponse?> GetAssetsByCityOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAssetsByCityAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAssetsByCityApiResponse"/>&gt;</returns>
        public async Task<IGetAssetsByCityApiResponse> GetAssetsByCityAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/search/cities"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/search/cities");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar3 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar3);

                    bearerTokenLocalVar3.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetAssetsByCityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAssetsByCityApiResponse>();
                        GetAssetsByCityApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/search/cities", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetAssetsByCityDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetAssetsByCity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAssetsByCityDefaultImplementation(e, "/search/cities", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetAssetsByCity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAssetsByCityApiResponse"/>
        /// </summary>
        public partial class GetAssetsByCityApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetAssetsByCityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAssetsByCityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAssetsByCityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAssetsByCityApiResponse(ILogger<GetAssetsByCityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetAssetsByCityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAssetsByCityApiResponse(ILogger<GetAssetsByCityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<AssetResponseDto>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<AssetResponseDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<AssetResponseDto>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetExploreDataDefaultImplementation(IGetExploreDataApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetExploreData(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetExploreData(ref bool suppressDefaultLog, IGetExploreDataApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetExploreDataDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetExploreData(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetExploreData(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExploreDataApiResponse"/>&gt;</returns>
        public async Task<IGetExploreDataApiResponse?> GetExploreDataOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetExploreDataAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExploreDataApiResponse"/>&gt;</returns>
        public async Task<IGetExploreDataApiResponse> GetExploreDataAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/search/explore"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/search/explore");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar3 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar3);

                    bearerTokenLocalVar3.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetExploreDataApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetExploreDataApiResponse>();
                        GetExploreDataApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/search/explore", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetExploreDataDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetExploreData(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetExploreDataDefaultImplementation(e, "/search/explore", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetExploreData(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetExploreDataApiResponse"/>
        /// </summary>
        public partial class GetExploreDataApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetExploreDataApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetExploreDataApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetExploreDataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetExploreDataApiResponse(ILogger<GetExploreDataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetExploreDataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetExploreDataApiResponse(ILogger<GetExploreDataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<SearchExploreResponseDto>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<SearchExploreResponseDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<SearchExploreResponseDto>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSearchSuggestions(ref SearchSuggestionType type, ref Option<string> country, ref Option<bool> includeNull, ref Option<string> lensModel, ref Option<string> make, ref Option<string> model, ref Option<string> state);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="country"></param>
        /// <param name="lensModel"></param>
        /// <param name="make"></param>
        /// <param name="model"></param>
        /// <param name="state"></param>
        /// <returns></returns>
        private void ValidateGetSearchSuggestions(Option<string> country, Option<string> lensModel, Option<string> make, Option<string> model, Option<string> state)
        {
            if (country.IsSet && country.Value == null)
                throw new ArgumentNullException(nameof(country));

            if (lensModel.IsSet && lensModel.Value == null)
                throw new ArgumentNullException(nameof(lensModel));

            if (make.IsSet && make.Value == null)
                throw new ArgumentNullException(nameof(make));

            if (model.IsSet && model.Value == null)
                throw new ArgumentNullException(nameof(model));

            if (state.IsSet && state.Value == null)
                throw new ArgumentNullException(nameof(state));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="type"></param>
        /// <param name="country"></param>
        /// <param name="includeNull"></param>
        /// <param name="lensModel"></param>
        /// <param name="make"></param>
        /// <param name="model"></param>
        /// <param name="state"></param>
        private void AfterGetSearchSuggestionsDefaultImplementation(IGetSearchSuggestionsApiResponse apiResponseLocalVar, SearchSuggestionType type, Option<string> country, Option<bool> includeNull, Option<string> lensModel, Option<string> make, Option<string> model, Option<string> state)
        {
            bool suppressDefaultLog = false;
            AfterGetSearchSuggestions(ref suppressDefaultLog, apiResponseLocalVar, type, country, includeNull, lensModel, make, model, state);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="type"></param>
        /// <param name="country"></param>
        /// <param name="includeNull"></param>
        /// <param name="lensModel"></param>
        /// <param name="make"></param>
        /// <param name="model"></param>
        /// <param name="state"></param>
        partial void AfterGetSearchSuggestions(ref bool suppressDefaultLog, IGetSearchSuggestionsApiResponse apiResponseLocalVar, SearchSuggestionType type, Option<string> country, Option<bool> includeNull, Option<string> lensModel, Option<string> make, Option<string> model, Option<string> state);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="type"></param>
        /// <param name="country"></param>
        /// <param name="includeNull"></param>
        /// <param name="lensModel"></param>
        /// <param name="make"></param>
        /// <param name="model"></param>
        /// <param name="state"></param>
        private void OnErrorGetSearchSuggestionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SearchSuggestionType type, Option<string> country, Option<bool> includeNull, Option<string> lensModel, Option<string> make, Option<string> model, Option<string> state)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSearchSuggestions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, type, country, includeNull, lensModel, make, model, state);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="type"></param>
        /// <param name="country"></param>
        /// <param name="includeNull"></param>
        /// <param name="lensModel"></param>
        /// <param name="make"></param>
        /// <param name="model"></param>
        /// <param name="state"></param>
        partial void OnErrorGetSearchSuggestions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SearchSuggestionType type, Option<string> country, Option<bool> includeNull, Option<string> lensModel, Option<string> make, Option<string> model, Option<string> state);

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="country"> (optional)</param>
        /// <param name="includeNull">This property was added in v111.0.0 (optional)</param>
        /// <param name="lensModel"> (optional)</param>
        /// <param name="make"> (optional)</param>
        /// <param name="model"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSearchSuggestionsApiResponse"/>&gt;</returns>
        public async Task<IGetSearchSuggestionsApiResponse?> GetSearchSuggestionsOrDefaultAsync(SearchSuggestionType type, Option<string> country = default, Option<bool> includeNull = default, Option<string> lensModel = default, Option<string> make = default, Option<string> model = default, Option<string> state = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSearchSuggestionsAsync(type, country, includeNull, lensModel, make, model, state, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="type"></param>
        /// <param name="country"> (optional)</param>
        /// <param name="includeNull">This property was added in v111.0.0 (optional)</param>
        /// <param name="lensModel"> (optional)</param>
        /// <param name="make"> (optional)</param>
        /// <param name="model"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSearchSuggestionsApiResponse"/>&gt;</returns>
        public async Task<IGetSearchSuggestionsApiResponse> GetSearchSuggestionsAsync(SearchSuggestionType type, Option<string> country = default, Option<bool> includeNull = default, Option<string> lensModel = default, Option<string> make = default, Option<string> model = default, Option<string> state = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSearchSuggestions(country, lensModel, make, model, state);

                FormatGetSearchSuggestions(ref type, ref country, ref includeNull, ref lensModel, ref make, ref model, ref state);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/search/suggestions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/search/suggestions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type);

                    if (country.IsSet)
                        parseQueryStringLocalVar["country"] = ClientUtils.ParameterToString(country.Value);

                    if (includeNull.IsSet)
                        parseQueryStringLocalVar["includeNull"] = ClientUtils.ParameterToString(includeNull.Value);

                    if (lensModel.IsSet)
                        parseQueryStringLocalVar["lensModel"] = ClientUtils.ParameterToString(lensModel.Value);

                    if (make.IsSet)
                        parseQueryStringLocalVar["make"] = ClientUtils.ParameterToString(make.Value);

                    if (model.IsSet)
                        parseQueryStringLocalVar["model"] = ClientUtils.ParameterToString(model.Value);

                    if (state.IsSet)
                        parseQueryStringLocalVar["state"] = ClientUtils.ParameterToString(state.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar3 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar3);

                    bearerTokenLocalVar3.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetSearchSuggestionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSearchSuggestionsApiResponse>();
                        GetSearchSuggestionsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/search/suggestions", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetSearchSuggestionsDefaultImplementation(apiResponseLocalVar, type, country, includeNull, lensModel, make, model, state);

                        Events.ExecuteOnGetSearchSuggestions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSearchSuggestionsDefaultImplementation(e, "/search/suggestions", uriBuilderLocalVar.Path, type, country, includeNull, lensModel, make, model, state);
                Events.ExecuteOnErrorGetSearchSuggestions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSearchSuggestionsApiResponse"/>
        /// </summary>
        public partial class GetSearchSuggestionsApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetSearchSuggestionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSearchSuggestionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSearchSuggestionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSearchSuggestionsApiResponse(ILogger<GetSearchSuggestionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetSearchSuggestionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSearchSuggestionsApiResponse(ILogger<GetSearchSuggestionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<string>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<string>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<string>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchAssetStatistics(StatisticsSearchDto statisticsSearchDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="statisticsSearchDto"></param>
        /// <returns></returns>
        private void ValidateSearchAssetStatistics(StatisticsSearchDto statisticsSearchDto)
        {
            if (statisticsSearchDto == null)
                throw new ArgumentNullException(nameof(statisticsSearchDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="statisticsSearchDto"></param>
        private void AfterSearchAssetStatisticsDefaultImplementation(ISearchAssetStatisticsApiResponse apiResponseLocalVar, StatisticsSearchDto statisticsSearchDto)
        {
            bool suppressDefaultLog = false;
            AfterSearchAssetStatistics(ref suppressDefaultLog, apiResponseLocalVar, statisticsSearchDto);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="statisticsSearchDto"></param>
        partial void AfterSearchAssetStatistics(ref bool suppressDefaultLog, ISearchAssetStatisticsApiResponse apiResponseLocalVar, StatisticsSearchDto statisticsSearchDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="statisticsSearchDto"></param>
        private void OnErrorSearchAssetStatisticsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, StatisticsSearchDto statisticsSearchDto)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchAssetStatistics(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, statisticsSearchDto);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="statisticsSearchDto"></param>
        partial void OnErrorSearchAssetStatistics(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, StatisticsSearchDto statisticsSearchDto);

        /// <summary>
        ///  This endpoint requires the &#x60;asset.statistics&#x60; permission.
        /// </summary>
        /// <param name="statisticsSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchAssetStatisticsApiResponse"/>&gt;</returns>
        public async Task<ISearchAssetStatisticsApiResponse?> SearchAssetStatisticsOrDefaultAsync(StatisticsSearchDto statisticsSearchDto, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchAssetStatisticsAsync(statisticsSearchDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  This endpoint requires the &#x60;asset.statistics&#x60; permission.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="statisticsSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchAssetStatisticsApiResponse"/>&gt;</returns>
        public async Task<ISearchAssetStatisticsApiResponse> SearchAssetStatisticsAsync(StatisticsSearchDto statisticsSearchDto, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchAssetStatistics(statisticsSearchDto);

                FormatSearchAssetStatistics(statisticsSearchDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/search/statistics"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/search/statistics");

                    httpRequestMessageLocalVar.Content = (statisticsSearchDto as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(statisticsSearchDto, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar3 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar3);

                    bearerTokenLocalVar3.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchAssetStatisticsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchAssetStatisticsApiResponse>();
                        SearchAssetStatisticsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/search/statistics", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchAssetStatisticsDefaultImplementation(apiResponseLocalVar, statisticsSearchDto);

                        Events.ExecuteOnSearchAssetStatistics(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchAssetStatisticsDefaultImplementation(e, "/search/statistics", uriBuilderLocalVar.Path, statisticsSearchDto);
                Events.ExecuteOnErrorSearchAssetStatistics(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchAssetStatisticsApiResponse"/>
        /// </summary>
        public partial class SearchAssetStatisticsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchAssetStatisticsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchAssetStatisticsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchAssetStatisticsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchAssetStatisticsApiResponse(ILogger<SearchAssetStatisticsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchAssetStatisticsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchAssetStatisticsApiResponse(ILogger<SearchAssetStatisticsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SearchStatisticsResponseDto? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SearchStatisticsResponseDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SearchStatisticsResponseDto? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchAssets(MetadataSearchDto metadataSearchDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="metadataSearchDto"></param>
        /// <returns></returns>
        private void ValidateSearchAssets(MetadataSearchDto metadataSearchDto)
        {
            if (metadataSearchDto == null)
                throw new ArgumentNullException(nameof(metadataSearchDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metadataSearchDto"></param>
        private void AfterSearchAssetsDefaultImplementation(ISearchAssetsApiResponse apiResponseLocalVar, MetadataSearchDto metadataSearchDto)
        {
            bool suppressDefaultLog = false;
            AfterSearchAssets(ref suppressDefaultLog, apiResponseLocalVar, metadataSearchDto);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metadataSearchDto"></param>
        partial void AfterSearchAssets(ref bool suppressDefaultLog, ISearchAssetsApiResponse apiResponseLocalVar, MetadataSearchDto metadataSearchDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metadataSearchDto"></param>
        private void OnErrorSearchAssetsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, MetadataSearchDto metadataSearchDto)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchAssets(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, metadataSearchDto);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metadataSearchDto"></param>
        partial void OnErrorSearchAssets(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, MetadataSearchDto metadataSearchDto);

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <param name="metadataSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchAssetsApiResponse"/>&gt;</returns>
        public async Task<ISearchAssetsApiResponse?> SearchAssetsOrDefaultAsync(MetadataSearchDto metadataSearchDto, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchAssetsAsync(metadataSearchDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchAssetsApiResponse"/>&gt;</returns>
        public async Task<ISearchAssetsApiResponse> SearchAssetsAsync(MetadataSearchDto metadataSearchDto, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchAssets(metadataSearchDto);

                FormatSearchAssets(metadataSearchDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/search/metadata"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/search/metadata");

                    httpRequestMessageLocalVar.Content = (metadataSearchDto as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(metadataSearchDto, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar3 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar3);

                    bearerTokenLocalVar3.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchAssetsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchAssetsApiResponse>();
                        SearchAssetsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/search/metadata", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchAssetsDefaultImplementation(apiResponseLocalVar, metadataSearchDto);

                        Events.ExecuteOnSearchAssets(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchAssetsDefaultImplementation(e, "/search/metadata", uriBuilderLocalVar.Path, metadataSearchDto);
                Events.ExecuteOnErrorSearchAssets(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchAssetsApiResponse"/>
        /// </summary>
        public partial class SearchAssetsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchAssetsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchAssetsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchAssetsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchAssetsApiResponse(ILogger<SearchAssetsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchAssetsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchAssetsApiResponse(ILogger<SearchAssetsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SearchResponseDto? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SearchResponseDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SearchResponseDto? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchLargeAssets(Option<List<Guid>> albumIds, ref Option<string?> city, ref Option<string?> country, ref Option<DateTime> createdAfter, ref Option<DateTime> createdBefore, ref Option<string> deviceId, ref Option<bool> isEncoded, ref Option<bool> isFavorite, ref Option<bool> isMotion, ref Option<bool> isNotInAlbum, ref Option<bool> isOffline, ref Option<string?> lensModel, ref Option<Guid?> libraryId, ref Option<string> make, ref Option<int> minFileSize, ref Option<string?> model, Option<List<Guid>> personIds, ref Option<decimal> rating, ref Option<decimal> size, ref Option<string?> state, Option<List<Guid>?> tagIds, ref Option<DateTime> takenAfter, ref Option<DateTime> takenBefore, ref Option<DateTime> trashedAfter, ref Option<DateTime> trashedBefore, ref Option<AssetTypeEnum> type, ref Option<DateTime> updatedAfter, ref Option<DateTime> updatedBefore, ref Option<AssetVisibility> visibility, ref Option<bool> withDeleted, ref Option<bool> withExif);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="albumIds"></param>
        /// <param name="deviceId"></param>
        /// <param name="make"></param>
        /// <param name="personIds"></param>
        /// <returns></returns>
        private void ValidateSearchLargeAssets(Option<List<Guid>> albumIds, Option<string> deviceId, Option<string> make, Option<List<Guid>> personIds)
        {
            if (albumIds.IsSet && albumIds.Value == null)
                throw new ArgumentNullException(nameof(albumIds));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (make.IsSet && make.Value == null)
                throw new ArgumentNullException(nameof(make));

            if (personIds.IsSet && personIds.Value == null)
                throw new ArgumentNullException(nameof(personIds));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="albumIds"></param>
        /// <param name="city"></param>
        /// <param name="country"></param>
        /// <param name="createdAfter"></param>
        /// <param name="createdBefore"></param>
        /// <param name="deviceId"></param>
        /// <param name="isEncoded"></param>
        /// <param name="isFavorite"></param>
        /// <param name="isMotion"></param>
        /// <param name="isNotInAlbum"></param>
        /// <param name="isOffline"></param>
        /// <param name="lensModel"></param>
        /// <param name="libraryId"></param>
        /// <param name="make"></param>
        /// <param name="minFileSize"></param>
        /// <param name="model"></param>
        /// <param name="personIds"></param>
        /// <param name="rating"></param>
        /// <param name="size"></param>
        /// <param name="state"></param>
        /// <param name="tagIds"></param>
        /// <param name="takenAfter"></param>
        /// <param name="takenBefore"></param>
        /// <param name="trashedAfter"></param>
        /// <param name="trashedBefore"></param>
        /// <param name="type"></param>
        /// <param name="updatedAfter"></param>
        /// <param name="updatedBefore"></param>
        /// <param name="visibility"></param>
        /// <param name="withDeleted"></param>
        /// <param name="withExif"></param>
        private void AfterSearchLargeAssetsDefaultImplementation(ISearchLargeAssetsApiResponse apiResponseLocalVar, Option<List<Guid>> albumIds, Option<string?> city, Option<string?> country, Option<DateTime> createdAfter, Option<DateTime> createdBefore, Option<string> deviceId, Option<bool> isEncoded, Option<bool> isFavorite, Option<bool> isMotion, Option<bool> isNotInAlbum, Option<bool> isOffline, Option<string?> lensModel, Option<Guid?> libraryId, Option<string> make, Option<int> minFileSize, Option<string?> model, Option<List<Guid>> personIds, Option<decimal> rating, Option<decimal> size, Option<string?> state, Option<List<Guid>?> tagIds, Option<DateTime> takenAfter, Option<DateTime> takenBefore, Option<DateTime> trashedAfter, Option<DateTime> trashedBefore, Option<AssetTypeEnum> type, Option<DateTime> updatedAfter, Option<DateTime> updatedBefore, Option<AssetVisibility> visibility, Option<bool> withDeleted, Option<bool> withExif)
        {
            bool suppressDefaultLog = false;
            AfterSearchLargeAssets(ref suppressDefaultLog, apiResponseLocalVar, albumIds, city, country, createdAfter, createdBefore, deviceId, isEncoded, isFavorite, isMotion, isNotInAlbum, isOffline, lensModel, libraryId, make, minFileSize, model, personIds, rating, size, state, tagIds, takenAfter, takenBefore, trashedAfter, trashedBefore, type, updatedAfter, updatedBefore, visibility, withDeleted, withExif);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="albumIds"></param>
        /// <param name="city"></param>
        /// <param name="country"></param>
        /// <param name="createdAfter"></param>
        /// <param name="createdBefore"></param>
        /// <param name="deviceId"></param>
        /// <param name="isEncoded"></param>
        /// <param name="isFavorite"></param>
        /// <param name="isMotion"></param>
        /// <param name="isNotInAlbum"></param>
        /// <param name="isOffline"></param>
        /// <param name="lensModel"></param>
        /// <param name="libraryId"></param>
        /// <param name="make"></param>
        /// <param name="minFileSize"></param>
        /// <param name="model"></param>
        /// <param name="personIds"></param>
        /// <param name="rating"></param>
        /// <param name="size"></param>
        /// <param name="state"></param>
        /// <param name="tagIds"></param>
        /// <param name="takenAfter"></param>
        /// <param name="takenBefore"></param>
        /// <param name="trashedAfter"></param>
        /// <param name="trashedBefore"></param>
        /// <param name="type"></param>
        /// <param name="updatedAfter"></param>
        /// <param name="updatedBefore"></param>
        /// <param name="visibility"></param>
        /// <param name="withDeleted"></param>
        /// <param name="withExif"></param>
        partial void AfterSearchLargeAssets(ref bool suppressDefaultLog, ISearchLargeAssetsApiResponse apiResponseLocalVar, Option<List<Guid>> albumIds, Option<string?> city, Option<string?> country, Option<DateTime> createdAfter, Option<DateTime> createdBefore, Option<string> deviceId, Option<bool> isEncoded, Option<bool> isFavorite, Option<bool> isMotion, Option<bool> isNotInAlbum, Option<bool> isOffline, Option<string?> lensModel, Option<Guid?> libraryId, Option<string> make, Option<int> minFileSize, Option<string?> model, Option<List<Guid>> personIds, Option<decimal> rating, Option<decimal> size, Option<string?> state, Option<List<Guid>?> tagIds, Option<DateTime> takenAfter, Option<DateTime> takenBefore, Option<DateTime> trashedAfter, Option<DateTime> trashedBefore, Option<AssetTypeEnum> type, Option<DateTime> updatedAfter, Option<DateTime> updatedBefore, Option<AssetVisibility> visibility, Option<bool> withDeleted, Option<bool> withExif);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="albumIds"></param>
        /// <param name="city"></param>
        /// <param name="country"></param>
        /// <param name="createdAfter"></param>
        /// <param name="createdBefore"></param>
        /// <param name="deviceId"></param>
        /// <param name="isEncoded"></param>
        /// <param name="isFavorite"></param>
        /// <param name="isMotion"></param>
        /// <param name="isNotInAlbum"></param>
        /// <param name="isOffline"></param>
        /// <param name="lensModel"></param>
        /// <param name="libraryId"></param>
        /// <param name="make"></param>
        /// <param name="minFileSize"></param>
        /// <param name="model"></param>
        /// <param name="personIds"></param>
        /// <param name="rating"></param>
        /// <param name="size"></param>
        /// <param name="state"></param>
        /// <param name="tagIds"></param>
        /// <param name="takenAfter"></param>
        /// <param name="takenBefore"></param>
        /// <param name="trashedAfter"></param>
        /// <param name="trashedBefore"></param>
        /// <param name="type"></param>
        /// <param name="updatedAfter"></param>
        /// <param name="updatedBefore"></param>
        /// <param name="visibility"></param>
        /// <param name="withDeleted"></param>
        /// <param name="withExif"></param>
        private void OnErrorSearchLargeAssetsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<List<Guid>> albumIds, Option<string?> city, Option<string?> country, Option<DateTime> createdAfter, Option<DateTime> createdBefore, Option<string> deviceId, Option<bool> isEncoded, Option<bool> isFavorite, Option<bool> isMotion, Option<bool> isNotInAlbum, Option<bool> isOffline, Option<string?> lensModel, Option<Guid?> libraryId, Option<string> make, Option<int> minFileSize, Option<string?> model, Option<List<Guid>> personIds, Option<decimal> rating, Option<decimal> size, Option<string?> state, Option<List<Guid>?> tagIds, Option<DateTime> takenAfter, Option<DateTime> takenBefore, Option<DateTime> trashedAfter, Option<DateTime> trashedBefore, Option<AssetTypeEnum> type, Option<DateTime> updatedAfter, Option<DateTime> updatedBefore, Option<AssetVisibility> visibility, Option<bool> withDeleted, Option<bool> withExif)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchLargeAssets(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, albumIds, city, country, createdAfter, createdBefore, deviceId, isEncoded, isFavorite, isMotion, isNotInAlbum, isOffline, lensModel, libraryId, make, minFileSize, model, personIds, rating, size, state, tagIds, takenAfter, takenBefore, trashedAfter, trashedBefore, type, updatedAfter, updatedBefore, visibility, withDeleted, withExif);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="albumIds"></param>
        /// <param name="city"></param>
        /// <param name="country"></param>
        /// <param name="createdAfter"></param>
        /// <param name="createdBefore"></param>
        /// <param name="deviceId"></param>
        /// <param name="isEncoded"></param>
        /// <param name="isFavorite"></param>
        /// <param name="isMotion"></param>
        /// <param name="isNotInAlbum"></param>
        /// <param name="isOffline"></param>
        /// <param name="lensModel"></param>
        /// <param name="libraryId"></param>
        /// <param name="make"></param>
        /// <param name="minFileSize"></param>
        /// <param name="model"></param>
        /// <param name="personIds"></param>
        /// <param name="rating"></param>
        /// <param name="size"></param>
        /// <param name="state"></param>
        /// <param name="tagIds"></param>
        /// <param name="takenAfter"></param>
        /// <param name="takenBefore"></param>
        /// <param name="trashedAfter"></param>
        /// <param name="trashedBefore"></param>
        /// <param name="type"></param>
        /// <param name="updatedAfter"></param>
        /// <param name="updatedBefore"></param>
        /// <param name="visibility"></param>
        /// <param name="withDeleted"></param>
        /// <param name="withExif"></param>
        partial void OnErrorSearchLargeAssets(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<List<Guid>> albumIds, Option<string?> city, Option<string?> country, Option<DateTime> createdAfter, Option<DateTime> createdBefore, Option<string> deviceId, Option<bool> isEncoded, Option<bool> isFavorite, Option<bool> isMotion, Option<bool> isNotInAlbum, Option<bool> isOffline, Option<string?> lensModel, Option<Guid?> libraryId, Option<string> make, Option<int> minFileSize, Option<string?> model, Option<List<Guid>> personIds, Option<decimal> rating, Option<decimal> size, Option<string?> state, Option<List<Guid>?> tagIds, Option<DateTime> takenAfter, Option<DateTime> takenBefore, Option<DateTime> trashedAfter, Option<DateTime> trashedBefore, Option<AssetTypeEnum> type, Option<DateTime> updatedAfter, Option<DateTime> updatedBefore, Option<AssetVisibility> visibility, Option<bool> withDeleted, Option<bool> withExif);

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <param name="albumIds"> (optional)</param>
        /// <param name="city"> (optional)</param>
        /// <param name="country"> (optional)</param>
        /// <param name="createdAfter"> (optional)</param>
        /// <param name="createdBefore"> (optional)</param>
        /// <param name="deviceId"> (optional)</param>
        /// <param name="isEncoded"> (optional)</param>
        /// <param name="isFavorite"> (optional)</param>
        /// <param name="isMotion"> (optional)</param>
        /// <param name="isNotInAlbum"> (optional)</param>
        /// <param name="isOffline"> (optional)</param>
        /// <param name="lensModel"> (optional)</param>
        /// <param name="libraryId"> (optional)</param>
        /// <param name="make"> (optional)</param>
        /// <param name="minFileSize"> (optional)</param>
        /// <param name="model"> (optional)</param>
        /// <param name="personIds"> (optional)</param>
        /// <param name="rating"> (optional)</param>
        /// <param name="size"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="tagIds"> (optional)</param>
        /// <param name="takenAfter"> (optional)</param>
        /// <param name="takenBefore"> (optional)</param>
        /// <param name="trashedAfter"> (optional)</param>
        /// <param name="trashedBefore"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="updatedAfter"> (optional)</param>
        /// <param name="updatedBefore"> (optional)</param>
        /// <param name="visibility"> (optional)</param>
        /// <param name="withDeleted"> (optional)</param>
        /// <param name="withExif"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchLargeAssetsApiResponse"/>&gt;</returns>
        public async Task<ISearchLargeAssetsApiResponse?> SearchLargeAssetsOrDefaultAsync(Option<List<Guid>> albumIds = default, Option<string?> city = default, Option<string?> country = default, Option<DateTime> createdAfter = default, Option<DateTime> createdBefore = default, Option<string> deviceId = default, Option<bool> isEncoded = default, Option<bool> isFavorite = default, Option<bool> isMotion = default, Option<bool> isNotInAlbum = default, Option<bool> isOffline = default, Option<string?> lensModel = default, Option<Guid?> libraryId = default, Option<string> make = default, Option<int> minFileSize = default, Option<string?> model = default, Option<List<Guid>> personIds = default, Option<decimal> rating = default, Option<decimal> size = default, Option<string?> state = default, Option<List<Guid>?> tagIds = default, Option<DateTime> takenAfter = default, Option<DateTime> takenBefore = default, Option<DateTime> trashedAfter = default, Option<DateTime> trashedBefore = default, Option<AssetTypeEnum> type = default, Option<DateTime> updatedAfter = default, Option<DateTime> updatedBefore = default, Option<AssetVisibility> visibility = default, Option<bool> withDeleted = default, Option<bool> withExif = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchLargeAssetsAsync(albumIds, city, country, createdAfter, createdBefore, deviceId, isEncoded, isFavorite, isMotion, isNotInAlbum, isOffline, lensModel, libraryId, make, minFileSize, model, personIds, rating, size, state, tagIds, takenAfter, takenBefore, trashedAfter, trashedBefore, type, updatedAfter, updatedBefore, visibility, withDeleted, withExif, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="albumIds"> (optional)</param>
        /// <param name="city"> (optional)</param>
        /// <param name="country"> (optional)</param>
        /// <param name="createdAfter"> (optional)</param>
        /// <param name="createdBefore"> (optional)</param>
        /// <param name="deviceId"> (optional)</param>
        /// <param name="isEncoded"> (optional)</param>
        /// <param name="isFavorite"> (optional)</param>
        /// <param name="isMotion"> (optional)</param>
        /// <param name="isNotInAlbum"> (optional)</param>
        /// <param name="isOffline"> (optional)</param>
        /// <param name="lensModel"> (optional)</param>
        /// <param name="libraryId"> (optional)</param>
        /// <param name="make"> (optional)</param>
        /// <param name="minFileSize"> (optional)</param>
        /// <param name="model"> (optional)</param>
        /// <param name="personIds"> (optional)</param>
        /// <param name="rating"> (optional)</param>
        /// <param name="size"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="tagIds"> (optional)</param>
        /// <param name="takenAfter"> (optional)</param>
        /// <param name="takenBefore"> (optional)</param>
        /// <param name="trashedAfter"> (optional)</param>
        /// <param name="trashedBefore"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="updatedAfter"> (optional)</param>
        /// <param name="updatedBefore"> (optional)</param>
        /// <param name="visibility"> (optional)</param>
        /// <param name="withDeleted"> (optional)</param>
        /// <param name="withExif"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchLargeAssetsApiResponse"/>&gt;</returns>
        public async Task<ISearchLargeAssetsApiResponse> SearchLargeAssetsAsync(Option<List<Guid>> albumIds = default, Option<string?> city = default, Option<string?> country = default, Option<DateTime> createdAfter = default, Option<DateTime> createdBefore = default, Option<string> deviceId = default, Option<bool> isEncoded = default, Option<bool> isFavorite = default, Option<bool> isMotion = default, Option<bool> isNotInAlbum = default, Option<bool> isOffline = default, Option<string?> lensModel = default, Option<Guid?> libraryId = default, Option<string> make = default, Option<int> minFileSize = default, Option<string?> model = default, Option<List<Guid>> personIds = default, Option<decimal> rating = default, Option<decimal> size = default, Option<string?> state = default, Option<List<Guid>?> tagIds = default, Option<DateTime> takenAfter = default, Option<DateTime> takenBefore = default, Option<DateTime> trashedAfter = default, Option<DateTime> trashedBefore = default, Option<AssetTypeEnum> type = default, Option<DateTime> updatedAfter = default, Option<DateTime> updatedBefore = default, Option<AssetVisibility> visibility = default, Option<bool> withDeleted = default, Option<bool> withExif = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchLargeAssets(albumIds, deviceId, make, personIds);

                FormatSearchLargeAssets(albumIds, ref city, ref country, ref createdAfter, ref createdBefore, ref deviceId, ref isEncoded, ref isFavorite, ref isMotion, ref isNotInAlbum, ref isOffline, ref lensModel, ref libraryId, ref make, ref minFileSize, ref model, personIds, ref rating, ref size, ref state, tagIds, ref takenAfter, ref takenBefore, ref trashedAfter, ref trashedBefore, ref type, ref updatedAfter, ref updatedBefore, ref visibility, ref withDeleted, ref withExif);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/search/large-assets"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/search/large-assets");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (albumIds.IsSet)
                        parseQueryStringLocalVar["albumIds"] = ClientUtils.ParameterToString(albumIds.Value);

                    if (city.IsSet)
                        parseQueryStringLocalVar["city"] = ClientUtils.ParameterToString(city.Value);

                    if (country.IsSet)
                        parseQueryStringLocalVar["country"] = ClientUtils.ParameterToString(country.Value);

                    if (createdAfter.IsSet)
                        parseQueryStringLocalVar["createdAfter"] = ClientUtils.ParameterToString(createdAfter.Value);

                    if (createdBefore.IsSet)
                        parseQueryStringLocalVar["createdBefore"] = ClientUtils.ParameterToString(createdBefore.Value);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (isEncoded.IsSet)
                        parseQueryStringLocalVar["isEncoded"] = ClientUtils.ParameterToString(isEncoded.Value);

                    if (isFavorite.IsSet)
                        parseQueryStringLocalVar["isFavorite"] = ClientUtils.ParameterToString(isFavorite.Value);

                    if (isMotion.IsSet)
                        parseQueryStringLocalVar["isMotion"] = ClientUtils.ParameterToString(isMotion.Value);

                    if (isNotInAlbum.IsSet)
                        parseQueryStringLocalVar["isNotInAlbum"] = ClientUtils.ParameterToString(isNotInAlbum.Value);

                    if (isOffline.IsSet)
                        parseQueryStringLocalVar["isOffline"] = ClientUtils.ParameterToString(isOffline.Value);

                    if (lensModel.IsSet)
                        parseQueryStringLocalVar["lensModel"] = ClientUtils.ParameterToString(lensModel.Value);

                    if (libraryId.IsSet)
                        parseQueryStringLocalVar["libraryId"] = ClientUtils.ParameterToString(libraryId.Value);

                    if (make.IsSet)
                        parseQueryStringLocalVar["make"] = ClientUtils.ParameterToString(make.Value);

                    if (minFileSize.IsSet)
                        parseQueryStringLocalVar["minFileSize"] = ClientUtils.ParameterToString(minFileSize.Value);

                    if (model.IsSet)
                        parseQueryStringLocalVar["model"] = ClientUtils.ParameterToString(model.Value);

                    if (personIds.IsSet)
                        parseQueryStringLocalVar["personIds"] = ClientUtils.ParameterToString(personIds.Value);

                    if (rating.IsSet)
                        parseQueryStringLocalVar["rating"] = ClientUtils.ParameterToString(rating.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (state.IsSet)
                        parseQueryStringLocalVar["state"] = ClientUtils.ParameterToString(state.Value);

                    if (tagIds.IsSet)
                        parseQueryStringLocalVar["tagIds"] = ClientUtils.ParameterToString(tagIds.Value);

                    if (takenAfter.IsSet)
                        parseQueryStringLocalVar["takenAfter"] = ClientUtils.ParameterToString(takenAfter.Value);

                    if (takenBefore.IsSet)
                        parseQueryStringLocalVar["takenBefore"] = ClientUtils.ParameterToString(takenBefore.Value);

                    if (trashedAfter.IsSet)
                        parseQueryStringLocalVar["trashedAfter"] = ClientUtils.ParameterToString(trashedAfter.Value);

                    if (trashedBefore.IsSet)
                        parseQueryStringLocalVar["trashedBefore"] = ClientUtils.ParameterToString(trashedBefore.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    if (updatedAfter.IsSet)
                        parseQueryStringLocalVar["updatedAfter"] = ClientUtils.ParameterToString(updatedAfter.Value);

                    if (updatedBefore.IsSet)
                        parseQueryStringLocalVar["updatedBefore"] = ClientUtils.ParameterToString(updatedBefore.Value);

                    if (visibility.IsSet)
                        parseQueryStringLocalVar["visibility"] = ClientUtils.ParameterToString(visibility.Value);

                    if (withDeleted.IsSet)
                        parseQueryStringLocalVar["withDeleted"] = ClientUtils.ParameterToString(withDeleted.Value);

                    if (withExif.IsSet)
                        parseQueryStringLocalVar["withExif"] = ClientUtils.ParameterToString(withExif.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar3 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar3);

                    bearerTokenLocalVar3.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchLargeAssetsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchLargeAssetsApiResponse>();
                        SearchLargeAssetsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/search/large-assets", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchLargeAssetsDefaultImplementation(apiResponseLocalVar, albumIds, city, country, createdAfter, createdBefore, deviceId, isEncoded, isFavorite, isMotion, isNotInAlbum, isOffline, lensModel, libraryId, make, minFileSize, model, personIds, rating, size, state, tagIds, takenAfter, takenBefore, trashedAfter, trashedBefore, type, updatedAfter, updatedBefore, visibility, withDeleted, withExif);

                        Events.ExecuteOnSearchLargeAssets(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchLargeAssetsDefaultImplementation(e, "/search/large-assets", uriBuilderLocalVar.Path, albumIds, city, country, createdAfter, createdBefore, deviceId, isEncoded, isFavorite, isMotion, isNotInAlbum, isOffline, lensModel, libraryId, make, minFileSize, model, personIds, rating, size, state, tagIds, takenAfter, takenBefore, trashedAfter, trashedBefore, type, updatedAfter, updatedBefore, visibility, withDeleted, withExif);
                Events.ExecuteOnErrorSearchLargeAssets(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchLargeAssetsApiResponse"/>
        /// </summary>
        public partial class SearchLargeAssetsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchLargeAssetsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchLargeAssetsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchLargeAssetsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchLargeAssetsApiResponse(ILogger<SearchLargeAssetsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchLargeAssetsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchLargeAssetsApiResponse(ILogger<SearchLargeAssetsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<AssetResponseDto>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<AssetResponseDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<AssetResponseDto>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchPerson(ref string name, ref Option<bool> withHidden);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        private void ValidateSearchPerson(string name)
        {
            if (name == null)
                throw new ArgumentNullException(nameof(name));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="withHidden"></param>
        private void AfterSearchPersonDefaultImplementation(ISearchPersonApiResponse apiResponseLocalVar, string name, Option<bool> withHidden)
        {
            bool suppressDefaultLog = false;
            AfterSearchPerson(ref suppressDefaultLog, apiResponseLocalVar, name, withHidden);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="withHidden"></param>
        partial void AfterSearchPerson(ref bool suppressDefaultLog, ISearchPersonApiResponse apiResponseLocalVar, string name, Option<bool> withHidden);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="withHidden"></param>
        private void OnErrorSearchPersonDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string name, Option<bool> withHidden)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchPerson(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, name, withHidden);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="withHidden"></param>
        partial void OnErrorSearchPerson(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string name, Option<bool> withHidden);

        /// <summary>
        ///  This endpoint requires the &#x60;person.read&#x60; permission.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="withHidden"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPersonApiResponse"/>&gt;</returns>
        public async Task<ISearchPersonApiResponse?> SearchPersonOrDefaultAsync(string name, Option<bool> withHidden = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchPersonAsync(name, withHidden, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  This endpoint requires the &#x60;person.read&#x60; permission.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="withHidden"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPersonApiResponse"/>&gt;</returns>
        public async Task<ISearchPersonApiResponse> SearchPersonAsync(string name, Option<bool> withHidden = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchPerson(name);

                FormatSearchPerson(ref name, ref withHidden);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/search/person"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/search/person");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name);

                    if (withHidden.IsSet)
                        parseQueryStringLocalVar["withHidden"] = ClientUtils.ParameterToString(withHidden.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar3 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar3);

                    bearerTokenLocalVar3.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchPersonApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchPersonApiResponse>();
                        SearchPersonApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/search/person", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchPersonDefaultImplementation(apiResponseLocalVar, name, withHidden);

                        Events.ExecuteOnSearchPerson(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchPersonDefaultImplementation(e, "/search/person", uriBuilderLocalVar.Path, name, withHidden);
                Events.ExecuteOnErrorSearchPerson(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchPersonApiResponse"/>
        /// </summary>
        public partial class SearchPersonApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchPersonApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchPersonApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchPersonApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchPersonApiResponse(ILogger<SearchPersonApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchPersonApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchPersonApiResponse(ILogger<SearchPersonApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<PersonResponseDto>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<PersonResponseDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<PersonResponseDto>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchPlaces(ref string name);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        private void ValidateSearchPlaces(string name)
        {
            if (name == null)
                throw new ArgumentNullException(nameof(name));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        private void AfterSearchPlacesDefaultImplementation(ISearchPlacesApiResponse apiResponseLocalVar, string name)
        {
            bool suppressDefaultLog = false;
            AfterSearchPlaces(ref suppressDefaultLog, apiResponseLocalVar, name);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        partial void AfterSearchPlaces(ref bool suppressDefaultLog, ISearchPlacesApiResponse apiResponseLocalVar, string name);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        private void OnErrorSearchPlacesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string name)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchPlaces(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, name);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        partial void OnErrorSearchPlaces(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string name);

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPlacesApiResponse"/>&gt;</returns>
        public async Task<ISearchPlacesApiResponse?> SearchPlacesOrDefaultAsync(string name, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchPlacesAsync(name, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPlacesApiResponse"/>&gt;</returns>
        public async Task<ISearchPlacesApiResponse> SearchPlacesAsync(string name, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchPlaces(name);

                FormatSearchPlaces(ref name);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/search/places"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/search/places");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar3 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar3);

                    bearerTokenLocalVar3.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchPlacesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchPlacesApiResponse>();
                        SearchPlacesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/search/places", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchPlacesDefaultImplementation(apiResponseLocalVar, name);

                        Events.ExecuteOnSearchPlaces(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchPlacesDefaultImplementation(e, "/search/places", uriBuilderLocalVar.Path, name);
                Events.ExecuteOnErrorSearchPlaces(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchPlacesApiResponse"/>
        /// </summary>
        public partial class SearchPlacesApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchPlacesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchPlacesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchPlacesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchPlacesApiResponse(ILogger<SearchPlacesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchPlacesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchPlacesApiResponse(ILogger<SearchPlacesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<PlacesResponseDto>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<PlacesResponseDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<PlacesResponseDto>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchRandom(RandomSearchDto randomSearchDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="randomSearchDto"></param>
        /// <returns></returns>
        private void ValidateSearchRandom(RandomSearchDto randomSearchDto)
        {
            if (randomSearchDto == null)
                throw new ArgumentNullException(nameof(randomSearchDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="randomSearchDto"></param>
        private void AfterSearchRandomDefaultImplementation(ISearchRandomApiResponse apiResponseLocalVar, RandomSearchDto randomSearchDto)
        {
            bool suppressDefaultLog = false;
            AfterSearchRandom(ref suppressDefaultLog, apiResponseLocalVar, randomSearchDto);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="randomSearchDto"></param>
        partial void AfterSearchRandom(ref bool suppressDefaultLog, ISearchRandomApiResponse apiResponseLocalVar, RandomSearchDto randomSearchDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="randomSearchDto"></param>
        private void OnErrorSearchRandomDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, RandomSearchDto randomSearchDto)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchRandom(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, randomSearchDto);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="randomSearchDto"></param>
        partial void OnErrorSearchRandom(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, RandomSearchDto randomSearchDto);

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <param name="randomSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRandomApiResponse"/>&gt;</returns>
        public async Task<ISearchRandomApiResponse?> SearchRandomOrDefaultAsync(RandomSearchDto randomSearchDto, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchRandomAsync(randomSearchDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="randomSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRandomApiResponse"/>&gt;</returns>
        public async Task<ISearchRandomApiResponse> SearchRandomAsync(RandomSearchDto randomSearchDto, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchRandom(randomSearchDto);

                FormatSearchRandom(randomSearchDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/search/random"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/search/random");

                    httpRequestMessageLocalVar.Content = (randomSearchDto as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(randomSearchDto, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar3 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar3);

                    bearerTokenLocalVar3.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchRandomApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchRandomApiResponse>();
                        SearchRandomApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/search/random", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchRandomDefaultImplementation(apiResponseLocalVar, randomSearchDto);

                        Events.ExecuteOnSearchRandom(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchRandomDefaultImplementation(e, "/search/random", uriBuilderLocalVar.Path, randomSearchDto);
                Events.ExecuteOnErrorSearchRandom(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchRandomApiResponse"/>
        /// </summary>
        public partial class SearchRandomApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchRandomApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchRandomApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchRandomApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchRandomApiResponse(ILogger<SearchRandomApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchRandomApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchRandomApiResponse(ILogger<SearchRandomApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<AssetResponseDto>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<AssetResponseDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<AssetResponseDto>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchSmart(SmartSearchDto smartSearchDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="smartSearchDto"></param>
        /// <returns></returns>
        private void ValidateSearchSmart(SmartSearchDto smartSearchDto)
        {
            if (smartSearchDto == null)
                throw new ArgumentNullException(nameof(smartSearchDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="smartSearchDto"></param>
        private void AfterSearchSmartDefaultImplementation(ISearchSmartApiResponse apiResponseLocalVar, SmartSearchDto smartSearchDto)
        {
            bool suppressDefaultLog = false;
            AfterSearchSmart(ref suppressDefaultLog, apiResponseLocalVar, smartSearchDto);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="smartSearchDto"></param>
        partial void AfterSearchSmart(ref bool suppressDefaultLog, ISearchSmartApiResponse apiResponseLocalVar, SmartSearchDto smartSearchDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="smartSearchDto"></param>
        private void OnErrorSearchSmartDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SmartSearchDto smartSearchDto)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchSmart(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, smartSearchDto);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="smartSearchDto"></param>
        partial void OnErrorSearchSmart(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SmartSearchDto smartSearchDto);

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <param name="smartSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchSmartApiResponse"/>&gt;</returns>
        public async Task<ISearchSmartApiResponse?> SearchSmartOrDefaultAsync(SmartSearchDto smartSearchDto, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchSmartAsync(smartSearchDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  This endpoint requires the &#x60;asset.read&#x60; permission.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="smartSearchDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchSmartApiResponse"/>&gt;</returns>
        public async Task<ISearchSmartApiResponse> SearchSmartAsync(SmartSearchDto smartSearchDto, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchSmart(smartSearchDto);

                FormatSearchSmart(smartSearchDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/search/smart"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/search/smart");

                    httpRequestMessageLocalVar.Content = (smartSearchDto as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(smartSearchDto, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar3 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar3);

                    bearerTokenLocalVar3.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchSmartApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchSmartApiResponse>();
                        SearchSmartApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/search/smart", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchSmartDefaultImplementation(apiResponseLocalVar, smartSearchDto);

                        Events.ExecuteOnSearchSmart(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchSmartDefaultImplementation(e, "/search/smart", uriBuilderLocalVar.Path, smartSearchDto);
                Events.ExecuteOnErrorSearchSmart(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchSmartApiResponse"/>
        /// </summary>
        public partial class SearchSmartApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchSmartApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchSmartApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchSmartApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchSmartApiResponse(ILogger<SearchSmartApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchSmartApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchSmartApiResponse(ILogger<SearchSmartApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SearchResponseDto? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SearchResponseDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SearchResponseDto? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
