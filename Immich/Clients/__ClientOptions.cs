/////////////////////////////////////////////////////////////////
//															   //
// This code is generated by a tool                            //
// https://github.com/StevenThuriot/dotnet-openapi-generator   //
//															   //
/////////////////////////////////////////////////////////////////

#nullable enable

#pragma warning disable CS8618 // Non-nullable variable must contain a non-null value when exiting constructor. Consider declaring it as nullable.

namespace Immich.Clients;

[System.CodeDom.Compiler.GeneratedCode("dotnet-openapi-generator", "8.0.0-preview.15+2dc8cfca012adb9b7e1a243f167db99da7b5cfe4")]
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public class ClientOptions
{
    private static readonly System.Text.Json.JsonSerializerOptions s_defaultOptions;
    static ClientOptions()
    {
        s_defaultOptions = new(System.Text.Json.JsonSerializerDefaults.Web);

        s_defaultOptions.PropertyNameCaseInsensitive = true;
        s_defaultOptions.PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase;
        s_defaultOptions.NumberHandling = System.Text.Json.Serialization.JsonNumberHandling.AllowReadingFromString;
        s_defaultOptions.DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull;

        s_defaultOptions.TypeInfoResolverChain.Insert(0, ImmichJsonSerializerContext.Default);
    }
    
    private readonly System.Text.Json.JsonSerializerOptions? _options;

    public ClientOptions() : this(s_defaultOptions) { }

    public ClientOptions(System.Text.Json.JsonSerializerOptions? options)
    {
        _options = options;
    }

    internal System.Threading.Tasks.Task<System.Net.Http.HttpRequestMessage> CreateRequest<T>(System.Net.Http.HttpMethod httpMethod, string path, T content, System.Threading.CancellationToken token)
    {
        System.Net.Http.HttpRequestMessage request = new(httpMethod, path);

        if (content is not null)
        {
            request.Content = CreateContent(content);
        }

        return InterceptRequest(request, token);
    }

    internal System.Threading.Tasks.Task<System.Net.Http.HttpRequestMessage> CreateRequest(System.Net.Http.HttpMethod httpMethod, string path, System.Threading.CancellationToken token)
    {
        System.Net.Http.HttpRequestMessage request = new(httpMethod, path);
        return InterceptRequest(request, token);
    }

    protected internal virtual System.Net.Http.HttpContent CreateContent<T>(T content) => new System.Net.Http.StringContent(SerializeContent(content), System.Text.Encoding.UTF8, "application/json");

    protected internal virtual System.Threading.Tasks.Task<System.Net.Http.HttpRequestMessage> InterceptRequest(System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken token)
    {
        return System.Threading.Tasks.Task.FromResult(request);
    }

    protected internal virtual string SerializeContent<T>(T content) => System.Text.Json.JsonSerializer.Serialize(content, options: _options);

    protected internal virtual System.Threading.Tasks.Task<T?> DeSerializeContent<T>(System.Net.Http.HttpResponseMessage response, System.Threading.CancellationToken token) => System.Net.Http.Json.HttpContentJsonExtensions.ReadFromJsonAsync<T>(response.Content, _options, token);

    protected internal virtual System.Threading.Tasks.Task InterceptResponse(System.Net.Http.HttpResponseMessage result, System.Threading.CancellationToken token)
    {
        result.EnsureSuccessStatusCode();
        return System.Threading.Tasks.Task.CompletedTask;
    }
}